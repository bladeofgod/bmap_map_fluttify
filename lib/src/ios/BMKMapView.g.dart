// ignore_for_file: non_constant_identifier_names, camel_case_types, missing_return, unused_import, unused_local_variable
//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

import 'dart:typed_data';

import 'package:bmap_map_fluttify/src/ios/ios.export.g.dart';
import 'package:bmap_map_fluttify/src/android/android.export.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import 'package:foundation_fluttify/foundation_fluttify.dart';

class BMKMapView extends UIView  {
  //region constants
  
  //endregion

  //region creators
  static Future<BMKMapView> create__() async {
    final int refId = await MethodChannel('com.fluttify/bmap_map_fluttify').invokeMethod('ObjectFactory::createBMKMapView');
    final object = BMKMapView()..refId = refId..tag = 'bmap_map_fluttify';
  
    kNativeObjectPool.add(object);
    return object;
  }
  
  static Future<List<BMKMapView>> create_batch__(int length) async {
    // if (#__check_param_size__#) {
    //   return Future.error('all args must has same length!');
    // }
    final List resultBatch = await MethodChannel('com.fluttify/bmap_map_fluttify').invokeMethod('ObjectFactory::create_batchBMKMapView', {'length': length});
  
    final List<BMKMapView> typedResult = resultBatch.map((result) => BMKMapView()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  //endregion

  //region getters
  Future<BMKMapType> get_mapType({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapType", {'refId': refId});
  
    return BMKMapType.values[result];
  }
  
  Future<BMKCoordinateRegion> get_region({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_region", {'refId': refId});
    kNativeObjectPool.add(BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify');
    return BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<BMKCoordinateRegion> get_limitMapRegion({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_limitMapRegion", {'refId': refId});
    kNativeObjectPool.add(BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify');
    return BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<CGPoint> get_compassPosition({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_compassPosition", {'refId': refId});
    kNativeObjectPool.add(CGPoint()..refId = result..tag = 'bmap_map_fluttify');
    return CGPoint()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<CGSize> get_compassSize({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_compassSize", {'refId': refId});
    kNativeObjectPool.add(CGSize()..refId = result..tag = 'bmap_map_fluttify');
    return CGSize()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<CLLocationCoordinate2D> get_centerCoordinate({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_centerCoordinate", {'refId': refId});
    kNativeObjectPool.add(CLLocationCoordinate2D()..refId = result..tag = 'bmap_map_fluttify');
    return CLLocationCoordinate2D()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<double> get_zoomLevel({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_zoomLevel", {'refId': refId});
  
    return result;
  }
  
  Future<double> get_minZoomLevel({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_minZoomLevel", {'refId': refId});
  
    return result;
  }
  
  Future<double> get_maxZoomLevel({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_maxZoomLevel", {'refId': refId});
  
    return result;
  }
  
  Future<int> get_rotation({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_rotation", {'refId': refId});
  
    return result;
  }
  
  Future<int> get_overlooking({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_overlooking", {'refId': refId});
  
    return result;
  }
  
  Future<int> get_minOverlooking({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_minOverlooking", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_buildingsEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isBuildingsEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_showMapPoi({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showMapPoi", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_trafficEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isTrafficEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_baiduHeatMapEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isBaiduHeatMapEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_gesturesEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_gesturesEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_zoomEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isZoomEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_zoomEnabledWithTap({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isZoomEnabledWithTap", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_scrollEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isScrollEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_overlookEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isOverlookEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_rotateEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isRotateEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_forceTouchEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_forceTouchEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_showMapScaleBar({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showMapScaleBar", {'refId': refId});
  
    return result;
  }
  
  Future<CGPoint> get_mapScaleBarPosition({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapScaleBarPosition", {'refId': refId});
    kNativeObjectPool.add(CGPoint()..refId = result..tag = 'bmap_map_fluttify');
    return CGPoint()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<CGSize> get_mapScaleBarSize({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapScaleBarSize", {'refId': refId});
    kNativeObjectPool.add(CGSize()..refId = result..tag = 'bmap_map_fluttify');
    return CGSize()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<BMKLogoPosition> get_logoPosition({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_logoPosition", {'refId': refId});
  
    return BMKLogoPosition.values[result];
  }
  
  Future<BMKMapRect> get_visibleMapRect({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_visibleMapRect", {'refId': refId});
    kNativeObjectPool.add(BMKMapRect()..refId = result..tag = 'bmap_map_fluttify');
    return BMKMapRect()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<UIEdgeInsets> get_mapPadding({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapPadding", {'refId': refId});
    kNativeObjectPool.add(UIEdgeInsets()..refId = result..tag = 'bmap_map_fluttify');
    return UIEdgeInsets()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<bool> get_updateTargetScreenPtWhenMapPaddingChanged({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_updateTargetScreenPtWhenMapPaddingChanged", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_ChangeWithTouchPointCenterEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isChangeWithTouchPointCenterEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_ChangeCenterWithDoubleTouchPointEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isChangeCenterWithDoubleTouchPointEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_baseIndoorMapEnabled({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_baseIndoorMapEnabled", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_showIndoorMapPoi({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showIndoorMapPoi", {'refId': refId});
  
    return result;
  }
  
  Future<bool> get_showsUserLocation({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showsUserLocation", {'refId': refId});
  
    return result;
  }
  
  Future<BMKUserTrackingMode> get_userTrackingMode({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_userTrackingMode", {'refId': refId});
  
    return BMKUserTrackingMode.values[result];
  }
  
  Future<bool> get_userLocationVisible({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isUserLocationVisible", {'refId': refId});
  
    return result;
  }
  
  Future<List> get_annotations({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_annotations", {'refId': refId});
    kNativeObjectPool.addAll((result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList());
    return (result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList();
  }
  
  Future<bool> get_isSelectedAnnotationViewFront({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isSelectedAnnotationViewFront", {'refId': refId});
  
    return result;
  }
  
  Future<List> get_overlays({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_overlays", {'refId': refId});
    kNativeObjectPool.addAll((result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList());
    return (result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList();
  }
  
  //endregion

  //region setters
  Future<void> set_delegate(BMKMapViewDelegate delegate, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_delegate', {'refId': refId, "delegate": delegate.refId});
  
    MethodChannel('BMKMapViewDelegate::Callback')
      .setMethodCallHandler((methodCall) async {
        final args = methodCall.arguments as Map;
        // final refId = args['callerRefId'] as int;
        // if (refId != this.refId) return;
  
        switch (methodCall.method) {
          case 'Callback::BMKMapViewDelegate::mapViewDidFinishLoading':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidFinishLoading([])');
            }
        
            // handle the native call
            delegate?.mapViewDidFinishLoading(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewDidRenderValidDataWithError':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidRenderValidDataWithError([])');
            }
        
            // handle the native call
            delegate?.mapViewDidRenderValidDataWithError(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', NSError()..refId = (args['error'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewDidFinishRendering':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidFinishRendering([])');
            }
        
            // handle the native call
            delegate?.mapViewDidFinishRendering(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewOnDrawMapFrame':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewOnDrawMapFrame([])');
            }
        
            // handle the native call
            delegate?.mapViewOnDrawMapFrame(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKMapStatus()..refId = (args['status'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewRegionWillChangeAnimated':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewRegionWillChangeAnimated([\'animated\':$args[animated]])');
            }
        
            // handle the native call
            delegate?.mapViewRegionWillChangeAnimated(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', args['animated']);
            break;
          case 'Callback::BMKMapViewDelegate::mapViewRegionWillChangeAnimatedreason':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewRegionWillChangeAnimatedreason([\'animated\':$args[animated]])');
            }
        
            // handle the native call
            delegate?.mapViewRegionWillChangeAnimatedreason(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', args['animated'], BMKRegionChangeReason.values[(args['reason'])]);
            break;
          case 'Callback::BMKMapViewDelegate::mapViewRegionDidChangeAnimated':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewRegionDidChangeAnimated([\'animated\':$args[animated]])');
            }
        
            // handle the native call
            delegate?.mapViewRegionDidChangeAnimated(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', args['animated']);
            break;
          case 'Callback::BMKMapViewDelegate::mapViewRegionDidChangeAnimatedreason':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewRegionDidChangeAnimatedreason([\'animated\':$args[animated]])');
            }
        
            // handle the native call
            delegate?.mapViewRegionDidChangeAnimatedreason(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', args['animated'], BMKRegionChangeReason.values[(args['reason'])]);
            break;
          case 'Callback::BMKMapViewDelegate::mapViewViewForAnnotation':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewViewForAnnotation([])');
            }
        
            // handle the native call
            delegate?.mapViewViewForAnnotation(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKShape()..refId = (args['annotation'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewDidAddAnnotationViews':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidAddAnnotationViews([])');
            }
        
            // handle the native call
            delegate?.mapViewDidAddAnnotationViews(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', (args['views'] as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList());
            break;
          case 'Callback::BMKMapViewDelegate::mapViewClickAnnotationView':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewClickAnnotationView([])');
            }
        
            // handle the native call
            delegate?.mapViewClickAnnotationView(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKAnnotationView()..refId = (args['view'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewDidSelectAnnotationView':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidSelectAnnotationView([])');
            }
        
            // handle the native call
            delegate?.mapViewDidSelectAnnotationView(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKAnnotationView()..refId = (args['view'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewDidDeselectAnnotationView':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidDeselectAnnotationView([])');
            }
        
            // handle the native call
            delegate?.mapViewDidDeselectAnnotationView(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKAnnotationView()..refId = (args['view'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewAnnotationViewdidChangeDragStatefromOldState':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewAnnotationViewdidChangeDragStatefromOldState([])');
            }
        
            // handle the native call
            delegate?.mapViewAnnotationViewdidChangeDragStatefromOldState(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKAnnotationView()..refId = (args['view'])..tag = 'bmap_map_fluttify', args['newState'], args['oldState']);
            break;
          case 'Callback::BMKMapViewDelegate::mapViewAnnotationViewForBubble':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewAnnotationViewForBubble([])');
            }
        
            // handle the native call
            delegate?.mapViewAnnotationViewForBubble(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKAnnotationView()..refId = (args['view'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewViewForOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewViewForOverlay([])');
            }
        
            // handle the native call
            delegate?.mapViewViewForOverlay(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKGroundOverlay()..refId = (args['overlay'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewDidAddOverlayViews':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewDidAddOverlayViews([])');
            }
        
            // handle the native call
            delegate?.mapViewDidAddOverlayViews(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', (args['overlayViews'] as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList());
            break;
          case 'Callback::BMKMapViewDelegate::mapViewOnClickedBMKOverlayView':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewOnClickedBMKOverlayView([])');
            }
        
            // handle the native call
            delegate?.mapViewOnClickedBMKOverlayView(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKOverlayView()..refId = (args['overlayView'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewOnClickedMapPoi':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewOnClickedMapPoi([])');
            }
        
            // handle the native call
            delegate?.mapViewOnClickedMapPoi(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', BMKMapPoi()..refId = (args['mapPoi'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapViewOnClickedMapBlank':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapViewOnClickedMapBlank([])');
            }
        
            // handle the native call
            delegate?.mapViewOnClickedMapBlank(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', CLLocationCoordinate2D()..refId = (args['coordinate'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapviewOnDoubleClick':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapviewOnDoubleClick([])');
            }
        
            // handle the native call
            delegate?.mapviewOnDoubleClick(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', CLLocationCoordinate2D()..refId = (args['coordinate'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapviewOnLongClick':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapviewOnLongClick([])');
            }
        
            // handle the native call
            delegate?.mapviewOnLongClick(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', CLLocationCoordinate2D()..refId = (args['coordinate'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapviewOnForceTouchforcemaximumPossibleForce':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapviewOnForceTouchforcemaximumPossibleForce([\'force\':$args[force], \'maximumPossibleForce\':$args[maximumPossibleForce]])');
            }
        
            // handle the native call
            delegate?.mapviewOnForceTouchforcemaximumPossibleForce(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', CLLocationCoordinate2D()..refId = (args['coordinate'])..tag = 'bmap_map_fluttify', args['force'], args['maximumPossibleForce']);
            break;
          case 'Callback::BMKMapViewDelegate::mapStatusDidChanged':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapStatusDidChanged([])');
            }
        
            // handle the native call
            delegate?.mapStatusDidChanged(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify');
            break;
          case 'Callback::BMKMapViewDelegate::mapviewBaseIndoorMapWithInbaseIndoorMapInfo':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: mapviewBaseIndoorMapWithInbaseIndoorMapInfo([\'flag\':$args[flag]])');
            }
        
            // handle the native call
            delegate?.mapviewBaseIndoorMapWithInbaseIndoorMapInfo(BMKMapView()..refId = (args['mapView'])..tag = 'bmap_map_fluttify', args['flag'], BMKBaseIndoorMapInfo()..refId = (args['info'])..tag = 'bmap_map_fluttify');
            break;
          default:
            break;
        }
      });
  }
  
  Future<void> set_mapType(BMKMapType mapType, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_mapType', {'refId': refId, "mapType": mapType.index});
  
  
  }
  
  Future<void> set_region(BMKCoordinateRegion region, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_region', {'refId': refId, "region": region.refId});
  
  
  }
  
  Future<void> set_limitMapRegion(BMKCoordinateRegion limitMapRegion, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_limitMapRegion', {'refId': refId, "limitMapRegion": limitMapRegion.refId});
  
  
  }
  
  Future<void> set_compassPosition(CGPoint compassPosition, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_compassPosition', {'refId': refId, "compassPosition": compassPosition.refId});
  
  
  }
  
  Future<void> set_centerCoordinate(CLLocationCoordinate2D centerCoordinate, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_centerCoordinate', {'refId': refId, "centerCoordinate": centerCoordinate.refId});
  
  
  }
  
  Future<void> set_zoomLevel(double zoomLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_zoomLevel', {'refId': refId, "zoomLevel": zoomLevel});
  
  
  }
  
  Future<void> set_minZoomLevel(double minZoomLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_minZoomLevel', {'refId': refId, "minZoomLevel": minZoomLevel});
  
  
  }
  
  Future<void> set_maxZoomLevel(double maxZoomLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_maxZoomLevel', {'refId': refId, "maxZoomLevel": maxZoomLevel});
  
  
  }
  
  Future<void> set_rotation(int rotation, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_rotation', {'refId': refId, "rotation": rotation});
  
  
  }
  
  Future<void> set_overlooking(int overlooking, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_overlooking', {'refId': refId, "overlooking": overlooking});
  
  
  }
  
  Future<void> set_minOverlooking(int minOverlooking, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_minOverlooking', {'refId': refId, "minOverlooking": minOverlooking});
  
  
  }
  
  Future<void> set_buildingsEnabled(bool buildingsEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_buildingsEnabled', {'refId': refId, "buildingsEnabled": buildingsEnabled});
  
  
  }
  
  Future<void> set_showMapPoi(bool showMapPoi, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_showMapPoi', {'refId': refId, "showMapPoi": showMapPoi});
  
  
  }
  
  Future<void> set_trafficEnabled(bool trafficEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_trafficEnabled', {'refId': refId, "trafficEnabled": trafficEnabled});
  
  
  }
  
  Future<void> set_baiduHeatMapEnabled(bool baiduHeatMapEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_baiduHeatMapEnabled', {'refId': refId, "baiduHeatMapEnabled": baiduHeatMapEnabled});
  
  
  }
  
  Future<void> set_gesturesEnabled(bool gesturesEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_gesturesEnabled', {'refId': refId, "gesturesEnabled": gesturesEnabled});
  
  
  }
  
  Future<void> set_zoomEnabled(bool zoomEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_zoomEnabled', {'refId': refId, "zoomEnabled": zoomEnabled});
  
  
  }
  
  Future<void> set_zoomEnabledWithTap(bool zoomEnabledWithTap, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_zoomEnabledWithTap', {'refId': refId, "zoomEnabledWithTap": zoomEnabledWithTap});
  
  
  }
  
  Future<void> set_scrollEnabled(bool scrollEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_scrollEnabled', {'refId': refId, "scrollEnabled": scrollEnabled});
  
  
  }
  
  Future<void> set_overlookEnabled(bool overlookEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_overlookEnabled', {'refId': refId, "overlookEnabled": overlookEnabled});
  
  
  }
  
  Future<void> set_rotateEnabled(bool rotateEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_rotateEnabled', {'refId': refId, "rotateEnabled": rotateEnabled});
  
  
  }
  
  Future<void> set_forceTouchEnabled(bool forceTouchEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_forceTouchEnabled', {'refId': refId, "forceTouchEnabled": forceTouchEnabled});
  
  
  }
  
  Future<void> set_showMapScaleBar(bool showMapScaleBar, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_showMapScaleBar', {'refId': refId, "showMapScaleBar": showMapScaleBar});
  
  
  }
  
  Future<void> set_mapScaleBarPosition(CGPoint mapScaleBarPosition, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_mapScaleBarPosition', {'refId': refId, "mapScaleBarPosition": mapScaleBarPosition.refId});
  
  
  }
  
  Future<void> set_logoPosition(BMKLogoPosition logoPosition, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_logoPosition', {'refId': refId, "logoPosition": logoPosition.index});
  
  
  }
  
  Future<void> set_visibleMapRect(BMKMapRect visibleMapRect, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_visibleMapRect', {'refId': refId, "visibleMapRect": visibleMapRect.refId});
  
  
  }
  
  Future<void> set_mapPadding(UIEdgeInsets mapPadding, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_mapPadding', {'refId': refId, "mapPadding": mapPadding.refId});
  
  
  }
  
  Future<void> set_updateTargetScreenPtWhenMapPaddingChanged(bool updateTargetScreenPtWhenMapPaddingChanged, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_updateTargetScreenPtWhenMapPaddingChanged', {'refId': refId, "updateTargetScreenPtWhenMapPaddingChanged": updateTargetScreenPtWhenMapPaddingChanged});
  
  
  }
  
  Future<void> set_ChangeWithTouchPointCenterEnabled(bool ChangeWithTouchPointCenterEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_ChangeWithTouchPointCenterEnabled', {'refId': refId, "ChangeWithTouchPointCenterEnabled": ChangeWithTouchPointCenterEnabled});
  
  
  }
  
  Future<void> set_ChangeCenterWithDoubleTouchPointEnabled(bool ChangeCenterWithDoubleTouchPointEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_ChangeCenterWithDoubleTouchPointEnabled', {'refId': refId, "ChangeCenterWithDoubleTouchPointEnabled": ChangeCenterWithDoubleTouchPointEnabled});
  
  
  }
  
  Future<void> set_baseIndoorMapEnabled(bool baseIndoorMapEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_baseIndoorMapEnabled', {'refId': refId, "baseIndoorMapEnabled": baseIndoorMapEnabled});
  
  
  }
  
  Future<void> set_showIndoorMapPoi(bool showIndoorMapPoi, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_showIndoorMapPoi', {'refId': refId, "showIndoorMapPoi": showIndoorMapPoi});
  
  
  }
  
  Future<void> set_showsUserLocation(bool showsUserLocation, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_showsUserLocation', {'refId': refId, "showsUserLocation": showsUserLocation});
  
  
  }
  
  Future<void> set_userTrackingMode(BMKUserTrackingMode userTrackingMode, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_userTrackingMode', {'refId': refId, "userTrackingMode": userTrackingMode.index});
  
  
  }
  
  Future<void> set_isSelectedAnnotationViewFront(bool isSelectedAnnotationViewFront, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::set_isSelectedAnnotationViewFront', {'refId': refId, "isSelectedAnnotationViewFront": isSelectedAnnotationViewFront});
  
  
  }
  
  //endregion

  //region methods
  static Future<void> customMapStyle(String customMapStyleJsonFilePath, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView::customMapStyle([\'customMapStyleJsonFilePath\':$customMapStyleJsonFilePath])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::customMapStyle', {"customMapStyleJsonFilePath": customMapStyleJsonFilePath});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  static Future<void> enableCustomMapStyle(bool enable, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView::enableCustomMapStyle([\'enable\':$enable])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::enableCustomMapStyle', {"enable": enable});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setCustomMapStylePath(String customMapStyleJsonFilePath, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCustomMapStylePath([\'customMapStyleJsonFilePath\':$customMapStyleJsonFilePath])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStylePath', {"customMapStyleJsonFilePath": customMapStyleJsonFilePath, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setCustomMapStylePathMode(String customMapStyleJsonFilePath, int mode, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCustomMapStylePath([\'customMapStyleJsonFilePath\':$customMapStyleJsonFilePath, \'mode\':$mode])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStylePathMode', {"customMapStyleJsonFilePath": customMapStyleJsonFilePath, "mode": mode, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setCustomMapStyleEnable(bool enable, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCustomMapStyleEnable([\'enable\':$enable])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStyleEnable', {"enable": enable, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setCustomMapStyleWithOptionPreLoadsuccessfailure(BMKCustomMapStyleOption option, void preLoad(String path), void success(String path), void failure(NSError error, String path), {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCustomMapStyleWithOption([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStyleWithOptionPreLoadsuccessfailure', {"option": option.refId, "refId": refId});
  
  
    // handle native call
    MethodChannel('BMKMapView::setCustomMapStyleWithOptionPreLoadsuccessfailure::Callback')
        .setMethodCallHandler((methodCall) async {
          final args = methodCall.arguments as Map;
          // final refId = args['callerRefId'] as int;
          // if (refId != this.refId) return;
  
          switch (methodCall.method) {
            case 'Callback::void|NSString path::void|NSString path':
              // print log
              if (fluttifyLogEnabled) {
        
              }
        
              // handle the native call
              preLoad(args['path']);
              break;
            case 'Callback::void|NSString path::void|NSString path':
              // print log
              if (fluttifyLogEnabled) {
        
              }
        
              // handle the native call
              success(args['path']);
              break;
            case 'Callback::void|NSError error, NSString path::void|NSError error, NSString path':
              // print log
              if (fluttifyLogEnabled) {
        
              }
        
              // handle the native call
              failure(NSError()..refId = (args['error'])..tag = 'bmap_map_fluttify', args['path']);
              break;
            default:
              break;
          }
        });
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<bool> setCustomTrafficColorForSmoothSlowcongestionsevereCongestion(UIColor smooth, UIColor slow, UIColor congestion, UIColor severeCongestion, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCustomTrafficColorForSmooth([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomTrafficColorForSmoothSlowcongestionsevereCongestion', {"smooth": smooth.refId, "slow": slow.refId, "congestion": congestion.refId, "severeCongestion": severeCongestion.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  static Future<void> willBackGround({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView::willBackGround([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::willBackGround', );
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  static Future<void> didForeGround({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView::didForeGround([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::didForeGround', );
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> viewWillAppear({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::viewWillAppear([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewWillAppear', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> viewWillDisappear({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::viewWillDisappear([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewWillDisappear', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> mapForceRefresh({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::mapForceRefresh([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::mapForceRefresh', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<bool> zoomIn({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::zoomIn([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::zoomIn', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<bool> zoomOut({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::zoomOut([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::zoomOut', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKCoordinateRegion> regionThatFits(BMKCoordinateRegion region, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::regionThatFits([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::regionThatFits', {"region": region.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify');
      return BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> setRegionAnimated(BMKCoordinateRegion region, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setRegion([\'animated\':$animated])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setRegionAnimated', {"region": region.refId, "animated": animated, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setCenterCoordinateAnimated(CLLocationCoordinate2D coordinate, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCenterCoordinate([\'animated\':$animated])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCenterCoordinateAnimated', {"coordinate": coordinate.refId, "animated": animated, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<UIImage> takeSnapshot({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::takeSnapshot([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::takeSnapshot', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(UIImage()..refId = result..tag = 'bmap_map_fluttify');
      return UIImage()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<UIImage> takeSnapshot__CGRect(CGRect rect, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::takeSnapshot([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::takeSnapshot__CGRect', {"rect": rect.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(UIImage()..refId = result..tag = 'bmap_map_fluttify');
      return UIImage()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> setCompassImage(UIImage image, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setCompassImage([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCompassImage', {"image": image.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setVisibleMapRectAnimated(BMKMapRect mapRect, bool animate, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setVisibleMapRect([\'animate\':$animate])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setVisibleMapRectAnimated', {"mapRect": mapRect.refId, "animate": animate, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKMapRect> mapRectThatFits(BMKMapRect mapRect, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::mapRectThatFits([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::mapRectThatFits', {"mapRect": mapRect.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapRect()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> setVisibleMapRectEdgePaddinganimated(BMKMapRect mapRect, UIEdgeInsets insets, bool animate, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setVisibleMapRect([\'animate\':$animate])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setVisibleMapRectEdgePaddinganimated', {"mapRect": mapRect.refId, "insets": insets.refId, "animate": animate, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> fitVisibleMapRectEdgePaddingwithAnimated(BMKMapRect mapRect, UIEdgeInsets insets, bool animate, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::fitVisibleMapRect([\'animate\':$animate])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::fitVisibleMapRectEdgePaddingwithAnimated', {"mapRect": mapRect.refId, "insets": insets.refId, "animate": animate, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKMapRect> mapRectThatFitsEdgePadding(BMKMapRect mapRect, UIEdgeInsets insets, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::mapRectThatFits([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::mapRectThatFitsEdgePadding', {"mapRect": mapRect.refId, "insets": insets.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapRect()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGPoint> convertCoordinateToPointToView(CLLocationCoordinate2D coordinate, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::convertCoordinate([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertCoordinateToPointToView', {"coordinate": coordinate.refId, "view": view.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGPoint()..refId = result..tag = 'bmap_map_fluttify');
      return CGPoint()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CLLocationCoordinate2D> convertPointToCoordinateFromView(CGPoint point, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::convertPoint([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertPointToCoordinateFromView', {"point": point.refId, "view": view.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CLLocationCoordinate2D()..refId = result..tag = 'bmap_map_fluttify');
      return CLLocationCoordinate2D()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGRect> convertRegionToRectToView(BMKCoordinateRegion region, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::convertRegion([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertRegionToRectToView', {"region": region.refId, "view": view.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGRect()..refId = result..tag = 'bmap_map_fluttify');
      return CGRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<BMKCoordinateRegion> convertRectToRegionFromView(CGRect rect, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::convertRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertRectToRegionFromView', {"rect": rect.refId, "view": view.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify');
      return BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGRect> convertMapRectToRectToView(BMKMapRect mapRect, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::convertMapRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertMapRectToRectToView', {"mapRect": mapRect.refId, "view": view.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGRect()..refId = result..tag = 'bmap_map_fluttify');
      return CGRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<BMKMapRect> convertRectToMapRectFromView(CGRect rect, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::convertRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertRectToMapRectFromView', {"rect": rect.refId, "view": view.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapRect()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGPoint> glPointForMapPoint(BMKMapPoint mapPoint, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::glPointForMapPoint([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::glPointForMapPoint', {"mapPoint": mapPoint.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGPoint()..refId = result..tag = 'bmap_map_fluttify');
      return CGPoint()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGPoint> glPointsForMapPointsCount(List<BMKMapPoint> mapPoints, int count, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::glPointsForMapPoints([\'count\':$count])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::glPointsForMapPointsCount', {"mapPoints": mapPoints.map((it) => it.refId).toList(), "count": count, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGPoint()..refId = result..tag = 'bmap_map_fluttify');
      return CGPoint()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> setMapCenterToScreenPt(CGPoint ptInScreen, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setMapCenterToScreenPt([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapCenterToScreenPt', {"ptInScreen": ptInScreen.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKMapStatus> getMapStatusFromCoordinateRegionEdgePadding(BMKCoordinateRegion region, UIEdgeInsets insets, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::getMapStatusFromCoordinateRegion([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::getMapStatusFromCoordinateRegionEdgePadding', {"region": region.refId, "insets": insets.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapStatus()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapStatus()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<BMKMapStatus> getMapStatus({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::getMapStatus([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::getMapStatus', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapStatus()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapStatus()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> setMapStatus(BMKMapStatus mapStatus, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setMapStatus([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapStatus', {"mapStatus": mapStatus.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setMapStatusWithAnimation(BMKMapStatus mapStatus, bool bAnimation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setMapStatus([\'bAnimation\':$bAnimation])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapStatusWithAnimation', {"mapStatus": mapStatus.refId, "bAnimation": bAnimation, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setMapStatusWithAnimationwithAnimationTime(BMKMapStatus mapStatus, bool bAnimation, int ulDuration, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::setMapStatus([\'bAnimation\':$bAnimation, \'ulDuration\':$ulDuration])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapStatusWithAnimationwithAnimationTime', {"mapStatus": mapStatus.refId, "bAnimation": bAnimation, "ulDuration": ulDuration, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<bool> isSurpportBaiduHeatMap({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::isSurpportBaiduHeatMap([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::isSurpportBaiduHeatMap', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKSwitchIndoorFloorError> switchBaseIndoorMapFloorWithID(String strFloor, String strID, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::switchBaseIndoorMapFloor([\'strFloor\':$strFloor, \'strID\':$strID])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::switchBaseIndoorMapFloorWithID', {"strFloor": strFloor, "strID": strID, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return BMKSwitchIndoorFloorError.values[result];
    }
  }
  
  Future<BMKBaseIndoorMapInfo> getFocusedBaseIndoorMapInfo({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::getFocusedBaseIndoorMapInfo([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::getFocusedBaseIndoorMapInfo', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKBaseIndoorMapInfo()..refId = result..tag = 'bmap_map_fluttify');
      return BMKBaseIndoorMapInfo()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> updateLocationViewWithParam(BMKLocationViewDisplayParam locationViewDisplayParam, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::updateLocationViewWithParam([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::updateLocationViewWithParam', {"locationViewDisplayParam": locationViewDisplayParam.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> updateLocationData(BMKUserLocation userLocation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::updateLocationData([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::updateLocationData', {"userLocation": userLocation.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> addAnnotation(BMKAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::addAnnotation([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addAnnotation', {"annotation": annotation.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> addAnnotations(List<NSObject> annotations, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::addAnnotations([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addAnnotations', {"annotations": annotations.map((it) => it.refId).toList(), "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> removeAnnotation(BMKAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::removeAnnotation([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeAnnotation', {"annotation": annotation.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> removeAnnotations(List<NSObject> annotations, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::removeAnnotations([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeAnnotations', {"annotations": annotations.map((it) => it.refId).toList(), "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKAnnotationView> viewForAnnotation(BMKAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::viewForAnnotation([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewForAnnotation', {"annotation": annotation.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKAnnotationView()..refId = result..tag = 'bmap_map_fluttify');
      return BMKAnnotationView()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<BMKAnnotationView> dequeueReusableAnnotationViewWithIdentifier(String identifier, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::dequeueReusableAnnotationViewWithIdentifier([\'identifier\':$identifier])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::dequeueReusableAnnotationViewWithIdentifier', {"identifier": identifier, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKAnnotationView()..refId = result..tag = 'bmap_map_fluttify');
      return BMKAnnotationView()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> selectAnnotationAnimated(BMKAnnotation annotation, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::selectAnnotation([\'animated\':$animated])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::selectAnnotationAnimated', {"annotation": annotation.refId, "animated": animated, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> deselectAnnotationAnimated(BMKAnnotation annotation, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::deselectAnnotation([\'animated\':$animated])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::deselectAnnotationAnimated', {"annotation": annotation.refId, "animated": animated, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> showAnnotationsAnimated(List<NSObject> annotations, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::showAnnotations([\'animated\':$animated])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::showAnnotationsAnimated', {"annotations": annotations.map((it) => it.refId).toList(), "animated": animated, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<List> annotationsInCoordinateBounds(BMKCoordinateBounds bounds, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::annotationsInCoordinateBounds([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::annotationsInCoordinateBounds', {"bounds": bounds.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.addAll((result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList());
      return (result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList();
    }
  }
  
  Future<void> addOverlay(BMKOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::addOverlay([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addOverlay', {"overlay": overlay.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> addOverlays(List<NSObject> overlays, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::addOverlays([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addOverlays', {"overlays": overlays.map((it) => it.refId).toList(), "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> removeOverlay(BMKOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::removeOverlay([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeOverlay', {"overlay": overlay.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> removeOverlays(List<NSObject> overlays, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::removeOverlays([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeOverlays', {"overlays": overlays.map((it) => it.refId).toList(), "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> insertOverlayAtIndex(BMKOverlay overlay, int index, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::insertOverlay([\'index\':$index])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::insertOverlayAtIndex', {"overlay": overlay.refId, "index": index, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> exchangeOverlayAtIndexWithOverlayAtIndex(int index1, int index2, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::exchangeOverlayAtIndex([\'index1\':$index1, \'index2\':$index2])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::exchangeOverlayAtIndexWithOverlayAtIndex', {"index1": index1, "index2": index2, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> insertOverlayAboveOverlay(BMKOverlay overlay, BMKOverlay sibling, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::insertOverlay([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::insertOverlayAboveOverlay', {"overlay": overlay.refId, "sibling": sibling.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> insertOverlayBelowOverlay(BMKOverlay overlay, BMKOverlay sibling, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::insertOverlay([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::insertOverlayBelowOverlay', {"overlay": overlay.refId, "sibling": sibling.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<BMKOverlayView> viewForOverlay(BMKOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::viewForOverlay([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewForOverlay', {"overlay": overlay.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKOverlayView()..refId = result..tag = 'bmap_map_fluttify');
      return BMKOverlayView()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<void> addHeatMap(BMKHeatMap heatMap, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::addHeatMap([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addHeatMap', {"heatMap": heatMap.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> removeHeatMap({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKMapView@$refId::removeHeatMap([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeHeatMap', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  //endregion
}

extension BMKMapView_Batch on List<BMKMapView> {
  //region getters
  Future<List<BMKMapType>> get_mapType_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapType_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKMapType.values[result]).toList();
  
    return typedResult;
  }
  
  Future<List<BMKCoordinateRegion>> get_region_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_region_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<BMKCoordinateRegion>> get_limitMapRegion_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_limitMapRegion_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<CGPoint>> get_compassPosition_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_compassPosition_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => CGPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<CGSize>> get_compassSize_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_compassSize_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => CGSize()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<CLLocationCoordinate2D>> get_centerCoordinate_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_centerCoordinate_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => CLLocationCoordinate2D()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<double>> get_zoomLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_zoomLevel_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<double>> get_minZoomLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_minZoomLevel_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<double>> get_maxZoomLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_maxZoomLevel_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<int>> get_rotation_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_rotation_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<int>> get_overlooking_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_overlooking_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<int>> get_minOverlooking_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_minOverlooking_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_buildingsEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isBuildingsEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_showMapPoi_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showMapPoi_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_trafficEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isTrafficEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_baiduHeatMapEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isBaiduHeatMapEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_gesturesEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_gesturesEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_zoomEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isZoomEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_zoomEnabledWithTap_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isZoomEnabledWithTap_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_scrollEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isScrollEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_overlookEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isOverlookEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_rotateEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isRotateEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_forceTouchEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_forceTouchEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_showMapScaleBar_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showMapScaleBar_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<CGPoint>> get_mapScaleBarPosition_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapScaleBarPosition_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => CGPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<CGSize>> get_mapScaleBarSize_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapScaleBarSize_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => CGSize()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<BMKLogoPosition>> get_logoPosition_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_logoPosition_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKLogoPosition.values[result]).toList();
  
    return typedResult;
  }
  
  Future<List<BMKMapRect>> get_visibleMapRect_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_visibleMapRect_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKMapRect()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<UIEdgeInsets>> get_mapPadding_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_mapPadding_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => UIEdgeInsets()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<bool>> get_updateTargetScreenPtWhenMapPaddingChanged_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_updateTargetScreenPtWhenMapPaddingChanged_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_ChangeWithTouchPointCenterEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isChangeWithTouchPointCenterEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_ChangeCenterWithDoubleTouchPointEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isChangeCenterWithDoubleTouchPointEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_baseIndoorMapEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_baseIndoorMapEnabled_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_showIndoorMapPoi_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showIndoorMapPoi_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_showsUserLocation_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_showsUserLocation_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<BMKUserTrackingMode>> get_userTrackingMode_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_userTrackingMode_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKUserTrackingMode.values[result]).toList();
  
    return typedResult;
  }
  
  Future<List<bool>> get_userLocationVisible_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isUserLocationVisible_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<List>> get_annotations_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_annotations_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => (result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList()).toList();
    kNativeObjectPool.addAll(typedResult.expand((e) => e));
    return typedResult;
  }
  
  Future<List<bool>> get_isSelectedAnnotationViewFront_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_isSelectedAnnotationViewFront_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => result).toList();
  
    return typedResult;
  }
  
  Future<List<List>> get_overlays_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKMapView::get_overlays_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => (result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList()).toList();
    kNativeObjectPool.addAll(typedResult.expand((e) => e));
    return typedResult;
  }
  
  //endregion

  //region methods
  Future<void> customMapStyle_batch(List<String> customMapStyleJsonFilePath, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::customMapStyle_batch', [for (int i = 0; i < this.length; i++) {"customMapStyleJsonFilePath": customMapStyleJsonFilePath[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> enableCustomMapStyle_batch(List<bool> enable, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::enableCustomMapStyle_batch', [for (int i = 0; i < this.length; i++) {"enable": enable[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setCustomMapStylePath_batch(List<String> customMapStyleJsonFilePath, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStylePath_batch', [for (int i = 0; i < this.length; i++) {"customMapStyleJsonFilePath": customMapStyleJsonFilePath[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setCustomMapStylePathMode_batch(List<String> customMapStyleJsonFilePath, List<int> mode, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStylePathMode_batch', [for (int i = 0; i < this.length; i++) {"customMapStyleJsonFilePath": customMapStyleJsonFilePath[i], "mode": mode[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setCustomMapStyleEnable_batch(List<bool> enable, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomMapStyleEnable_batch', [for (int i = 0; i < this.length; i++) {"enable": enable[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<bool>> setCustomTrafficColorForSmoothSlowcongestionsevereCongestion_batch(List<UIColor> smooth, List<UIColor> slow, List<UIColor> congestion, List<UIColor> severeCongestion, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCustomTrafficColorForSmoothSlowcongestionsevereCongestion_batch', [for (int i = 0; i < this.length; i++) {"smooth": smooth[i].refId, "slow": slow[i].refId, "congestion": congestion[i].refId, "severeCongestion": severeCongestion[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> willBackGround_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::willBackGround_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> didForeGround_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::didForeGround_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> viewWillAppear_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewWillAppear_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> viewWillDisappear_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewWillDisappear_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> mapForceRefresh_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::mapForceRefresh_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<bool>> zoomIn_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::zoomIn_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<bool>> zoomOut_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::zoomOut_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKCoordinateRegion>> regionThatFits_batch(List<BMKCoordinateRegion> region, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::regionThatFits_batch', [for (int i = 0; i < this.length; i++) {"region": region[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> setRegionAnimated_batch(List<BMKCoordinateRegion> region, List<bool> animated, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setRegionAnimated_batch', [for (int i = 0; i < this.length; i++) {"region": region[i].refId, "animated": animated[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setCenterCoordinateAnimated_batch(List<CLLocationCoordinate2D> coordinate, List<bool> animated, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCenterCoordinateAnimated_batch', [for (int i = 0; i < this.length; i++) {"coordinate": coordinate[i].refId, "animated": animated[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<UIImage>> takeSnapshot_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::takeSnapshot_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => UIImage()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<UIImage>> takeSnapshot__CGRect_batch(List<CGRect> rect, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::takeSnapshot__CGRect_batch', [for (int i = 0; i < this.length; i++) {"rect": rect[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => UIImage()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> setCompassImage_batch(List<UIImage> image, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setCompassImage_batch', [for (int i = 0; i < this.length; i++) {"image": image[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setVisibleMapRectAnimated_batch(List<BMKMapRect> mapRect, List<bool> animate, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setVisibleMapRectAnimated_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "animate": animate[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKMapRect>> mapRectThatFits_batch(List<BMKMapRect> mapRect, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::mapRectThatFits_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> setVisibleMapRectEdgePaddinganimated_batch(List<BMKMapRect> mapRect, List<UIEdgeInsets> insets, List<bool> animate, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setVisibleMapRectEdgePaddinganimated_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "insets": insets[i].refId, "animate": animate[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> fitVisibleMapRectEdgePaddingwithAnimated_batch(List<BMKMapRect> mapRect, List<UIEdgeInsets> insets, List<bool> animate, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::fitVisibleMapRectEdgePaddingwithAnimated_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "insets": insets[i].refId, "animate": animate[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKMapRect>> mapRectThatFitsEdgePadding_batch(List<BMKMapRect> mapRect, List<UIEdgeInsets> insets, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::mapRectThatFitsEdgePadding_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "insets": insets[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGPoint>> convertCoordinateToPointToView_batch(List<CLLocationCoordinate2D> coordinate, List<UIView> view, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertCoordinateToPointToView_batch', [for (int i = 0; i < this.length; i++) {"coordinate": coordinate[i].refId, "view": view[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CLLocationCoordinate2D>> convertPointToCoordinateFromView_batch(List<CGPoint> point, List<UIView> view, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertPointToCoordinateFromView_batch', [for (int i = 0; i < this.length; i++) {"point": point[i].refId, "view": view[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CLLocationCoordinate2D()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGRect>> convertRegionToRectToView_batch(List<BMKCoordinateRegion> region, List<UIView> view, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertRegionToRectToView_batch', [for (int i = 0; i < this.length; i++) {"region": region[i].refId, "view": view[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<BMKCoordinateRegion>> convertRectToRegionFromView_batch(List<CGRect> rect, List<UIView> view, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertRectToRegionFromView_batch', [for (int i = 0; i < this.length; i++) {"rect": rect[i].refId, "view": view[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKCoordinateRegion()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGRect>> convertMapRectToRectToView_batch(List<BMKMapRect> mapRect, List<UIView> view, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertMapRectToRectToView_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "view": view[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<BMKMapRect>> convertRectToMapRectFromView_batch(List<CGRect> rect, List<UIView> view, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::convertRectToMapRectFromView_batch', [for (int i = 0; i < this.length; i++) {"rect": rect[i].refId, "view": view[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGPoint>> glPointForMapPoint_batch(List<BMKMapPoint> mapPoint, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::glPointForMapPoint_batch', [for (int i = 0; i < this.length; i++) {"mapPoint": mapPoint[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGPoint>> glPointsForMapPointsCount_batch(List<List<BMKMapPoint>> mapPoints, List<int> count, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::glPointsForMapPointsCount_batch', [for (int i = 0; i < this.length; i++) {"mapPoints": mapPoints[i].map((it) => it.refId).toList(), "count": count[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> setMapCenterToScreenPt_batch(List<CGPoint> ptInScreen, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapCenterToScreenPt_batch', [for (int i = 0; i < this.length; i++) {"ptInScreen": ptInScreen[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKMapStatus>> getMapStatusFromCoordinateRegionEdgePadding_batch(List<BMKCoordinateRegion> region, List<UIEdgeInsets> insets, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::getMapStatusFromCoordinateRegionEdgePadding_batch', [for (int i = 0; i < this.length; i++) {"region": region[i].refId, "insets": insets[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapStatus()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<BMKMapStatus>> getMapStatus_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::getMapStatus_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapStatus()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> setMapStatus_batch(List<BMKMapStatus> mapStatus, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapStatus_batch', [for (int i = 0; i < this.length; i++) {"mapStatus": mapStatus[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setMapStatusWithAnimation_batch(List<BMKMapStatus> mapStatus, List<bool> bAnimation, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapStatusWithAnimation_batch', [for (int i = 0; i < this.length; i++) {"mapStatus": mapStatus[i].refId, "bAnimation": bAnimation[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setMapStatusWithAnimationwithAnimationTime_batch(List<BMKMapStatus> mapStatus, List<bool> bAnimation, List<int> ulDuration, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::setMapStatusWithAnimationwithAnimationTime_batch', [for (int i = 0; i < this.length; i++) {"mapStatus": mapStatus[i].refId, "bAnimation": bAnimation[i], "ulDuration": ulDuration[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<bool>> isSurpportBaiduHeatMap_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::isSurpportBaiduHeatMap_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKSwitchIndoorFloorError>> switchBaseIndoorMapFloorWithID_batch(List<String> strFloor, List<String> strID, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::switchBaseIndoorMapFloorWithID_batch', [for (int i = 0; i < this.length; i++) {"strFloor": strFloor[i], "strID": strID[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKSwitchIndoorFloorError.values[result]).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKBaseIndoorMapInfo>> getFocusedBaseIndoorMapInfo_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::getFocusedBaseIndoorMapInfo_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKBaseIndoorMapInfo()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> updateLocationViewWithParam_batch(List<BMKLocationViewDisplayParam> locationViewDisplayParam, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::updateLocationViewWithParam_batch', [for (int i = 0; i < this.length; i++) {"locationViewDisplayParam": locationViewDisplayParam[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> updateLocationData_batch(List<BMKUserLocation> userLocation, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::updateLocationData_batch', [for (int i = 0; i < this.length; i++) {"userLocation": userLocation[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> addAnnotation_batch(List<BMKAnnotation> annotation, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addAnnotation_batch', [for (int i = 0; i < this.length; i++) {"annotation": annotation[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> addAnnotations_batch(List<List<NSObject>> annotations, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addAnnotations_batch', [for (int i = 0; i < this.length; i++) {"annotations": annotations[i].map((it) => it.refId).toList(), "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> removeAnnotation_batch(List<BMKAnnotation> annotation, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeAnnotation_batch', [for (int i = 0; i < this.length; i++) {"annotation": annotation[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> removeAnnotations_batch(List<List<NSObject>> annotations, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeAnnotations_batch', [for (int i = 0; i < this.length; i++) {"annotations": annotations[i].map((it) => it.refId).toList(), "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKAnnotationView>> viewForAnnotation_batch(List<BMKAnnotation> annotation, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewForAnnotation_batch', [for (int i = 0; i < this.length; i++) {"annotation": annotation[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKAnnotationView()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<BMKAnnotationView>> dequeueReusableAnnotationViewWithIdentifier_batch(List<String> identifier, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::dequeueReusableAnnotationViewWithIdentifier_batch', [for (int i = 0; i < this.length; i++) {"identifier": identifier[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKAnnotationView()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> selectAnnotationAnimated_batch(List<BMKAnnotation> annotation, List<bool> animated, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::selectAnnotationAnimated_batch', [for (int i = 0; i < this.length; i++) {"annotation": annotation[i].refId, "animated": animated[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> deselectAnnotationAnimated_batch(List<BMKAnnotation> annotation, List<bool> animated, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::deselectAnnotationAnimated_batch', [for (int i = 0; i < this.length; i++) {"annotation": annotation[i].refId, "animated": animated[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> showAnnotationsAnimated_batch(List<List<NSObject>> annotations, List<bool> animated, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::showAnnotationsAnimated_batch', [for (int i = 0; i < this.length; i++) {"annotations": annotations[i].map((it) => it.refId).toList(), "animated": animated[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<List>> annotationsInCoordinateBounds_batch(List<BMKCoordinateBounds> bounds, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::annotationsInCoordinateBounds_batch', [for (int i = 0; i < this.length; i++) {"bounds": bounds[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => (result as List).cast<int>().map((it) => NSObject()..refId = it..tag = 'bmap_map_fluttify').toList()).toList();
      kNativeObjectPool.addAll(typedResult.expand((e) => e));
      return typedResult;
    }
  }
  
  Future<void> addOverlay_batch(List<BMKOverlay> overlay, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addOverlay_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> addOverlays_batch(List<List<NSObject>> overlays, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addOverlays_batch', [for (int i = 0; i < this.length; i++) {"overlays": overlays[i].map((it) => it.refId).toList(), "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> removeOverlay_batch(List<BMKOverlay> overlay, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeOverlay_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> removeOverlays_batch(List<List<NSObject>> overlays, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeOverlays_batch', [for (int i = 0; i < this.length; i++) {"overlays": overlays[i].map((it) => it.refId).toList(), "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> insertOverlayAtIndex_batch(List<BMKOverlay> overlay, List<int> index, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::insertOverlayAtIndex_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "index": index[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> exchangeOverlayAtIndexWithOverlayAtIndex_batch(List<int> index1, List<int> index2, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::exchangeOverlayAtIndexWithOverlayAtIndex_batch', [for (int i = 0; i < this.length; i++) {"index1": index1[i], "index2": index2[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> insertOverlayAboveOverlay_batch(List<BMKOverlay> overlay, List<BMKOverlay> sibling, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::insertOverlayAboveOverlay_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "sibling": sibling[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> insertOverlayBelowOverlay_batch(List<BMKOverlay> overlay, List<BMKOverlay> sibling, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::insertOverlayBelowOverlay_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "sibling": sibling[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<BMKOverlayView>> viewForOverlay_batch(List<BMKOverlay> overlay, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::viewForOverlay_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKOverlayView()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<void> addHeatMap_batch(List<BMKHeatMap> heatMap, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::addHeatMap_batch', [for (int i = 0; i < this.length; i++) {"heatMap": heatMap[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> removeHeatMap_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKMapView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKMapView::removeHeatMap_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  //endregion
}