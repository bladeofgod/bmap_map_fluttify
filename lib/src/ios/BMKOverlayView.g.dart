// ignore_for_file: non_constant_identifier_names, camel_case_types, missing_return, unused_import, unused_local_variable
//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

import 'dart:typed_data';

import 'package:bmap_map_fluttify/src/ios/ios.export.g.dart';
import 'package:bmap_map_fluttify/src/android/android.export.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import 'package:foundation_fluttify/foundation_fluttify.dart';

class BMKOverlayView extends UIView  {
  //region constants
  
  //endregion

  //region creators
  static Future<BMKOverlayView> create__() async {
    final int refId = await MethodChannel('com.fluttify/bmap_map_fluttify').invokeMethod('ObjectFactory::createBMKOverlayView');
    final object = BMKOverlayView()..refId = refId..tag = 'bmap_map_fluttify';
  
    kNativeObjectPool.add(object);
    return object;
  }
  
  static Future<List<BMKOverlayView>> create_batch__(int length) async {
    // if (#__check_param_size__#) {
    //   return Future.error('all args must has same length!');
    // }
    final List resultBatch = await MethodChannel('com.fluttify/bmap_map_fluttify').invokeMethod('ObjectFactory::create_batchBMKOverlayView', {'length': length});
  
    final List<BMKOverlayView> typedResult = resultBatch.map((result) => BMKOverlayView()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  //endregion

  //region getters
  Future<BMKOverlay> get_overlay({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKOverlayView::get_overlay", {'refId': refId});
    kNativeObjectPool.add(BMKGroundOverlay()..refId = result..tag = 'bmap_map_fluttify');
    return BMKGroundOverlay()..refId = result..tag = 'bmap_map_fluttify';
  }
  
  Future<List<UIColor>> get_colors({bool viewChannel = true}) async {
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKOverlayView::get_colors", {'refId': refId});
    kNativeObjectPool.addAll((result as List).cast<int>().map((it) => UIColor()..refId = it..tag = 'bmap_map_fluttify').toList());
    return (result as List).cast<int>().map((it) => UIColor()..refId = it..tag = 'bmap_map_fluttify').toList();
  }
  
  //endregion

  //region setters
  Future<void> set_colors(List<UIColor> colors, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::set_colors', {'refId': refId, "colors": colors.map((it) => it.refId).toList()});
  
  
  }
  
  //endregion

  //region methods
  Future<void> setOverlayGeometryDelegate(NSObject delegate, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::setOverlayGeometryDelegate([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::setOverlayGeometryDelegate', {"delegate": delegate.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<NSObject> initWithOverlay(BMKOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::initWithOverlay([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::initWithOverlay', {"overlay": overlay.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(NSObject()..refId = result..tag = 'bmap_map_fluttify');
      return NSObject()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGPoint> pointForMapPoint(BMKMapPoint mapPoint, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::pointForMapPoint([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::pointForMapPoint', {"mapPoint": mapPoint.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGPoint()..refId = result..tag = 'bmap_map_fluttify');
      return CGPoint()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<BMKMapPoint> mapPointForPoint(CGPoint point, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::mapPointForPoint([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::mapPointForPoint', {"point": point.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapPoint()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapPoint()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<CGRect> rectForMapRect(BMKMapRect mapRect, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::rectForMapRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::rectForMapRect', {"mapRect": mapRect.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(CGRect()..refId = result..tag = 'bmap_map_fluttify');
      return CGRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<BMKMapRect> mapRectForRect(CGRect rect, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::mapRectForRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::mapRectForRect', {"rect": rect.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
      kNativeObjectPool.add(BMKMapRect()..refId = result..tag = 'bmap_map_fluttify');
      return BMKMapRect()..refId = result..tag = 'bmap_map_fluttify';
    }
  }
  
  Future<bool> canDrawMapRectZoomScale(BMKMapRect mapRect, double zoomScale, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::canDrawMapRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::canDrawMapRectZoomScale', {"mapRect": mapRect.refId, "zoomScale": zoomScale, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setNeedsDisplayInMapRect(BMKMapRect mapRect, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::setNeedsDisplayInMapRect([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::setNeedsDisplayInMapRect', {"mapRect": mapRect.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderLinesWithPointsPointCountstrokeColorlineWidthlooped(List<BMKMapPoint> points, int pointCount, UIColor strokeColor, double lineWidth, bool looped, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderLinesWithPoints([\'pointCount\':$pointCount, \'lineWidth\':$lineWidth, \'looped\':$looped])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderLinesWithPointsPointCountstrokeColorlineWidthlooped', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "strokeColor": strokeColor.refId, "lineWidth": lineWidth, "looped": looped, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDashType(List<BMKMapPoint> points, int pointCount, UIColor strokeColor, double lineWidth, bool looped, BMKLineDashType lineDashType, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderLinesWithPoints([\'pointCount\':$pointCount, \'lineWidth\':$lineWidth, \'looped\':$looped])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDashType', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "strokeColor": strokeColor.refId, "lineWidth": lineWidth, "looped": looped, "lineDashType": lineDashType.index, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDash(List<BMKMapPoint> points, int pointCount, UIColor strokeColor, double lineWidth, bool looped, bool lineDash, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderLinesWithPoints([\'pointCount\':$pointCount, \'lineWidth\':$lineWidth, \'looped\':$looped, \'lineDash\':$lineDash])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDash', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "strokeColor": strokeColor.refId, "lineWidth": lineWidth, "looped": looped, "lineDash": lineDash, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocus(List<NSObject> partPt, double lineWidth, List<NSObject> textureIndexs, bool isFoucs, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderTexturedLinesWithPartPoints([\'lineWidth\':$lineWidth, \'isFoucs\':$isFoucs])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocus', {"partPt": partPt.map((it) => it.refId).toList(), "lineWidth": lineWidth, "textureIndexs": textureIndexs.map((it) => it.refId).toList(), "isFoucs": isFoucs, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocustileTexturekeepScale(List<NSObject> partPt, double lineWidth, List<NSObject> textureIndexs, bool isFoucs, bool tileTexture, bool keepscale, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderTexturedLinesWithPartPoints([\'lineWidth\':$lineWidth, \'isFoucs\':$isFoucs, \'tileTexture\':$tileTexture, \'keepscale\':$keepscale])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocustileTexturekeepScale', {"partPt": partPt.map((it) => it.refId).toList(), "lineWidth": lineWidth, "textureIndexs": textureIndexs.map((it) => it.refId).toList(), "isFoucs": isFoucs, "tileTexture": tileTexture, "keepscale": keepscale, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderMultiTexturedPolyLineWithPartPointsLineWidthtextureIndexsisFoucskeepScalelineJoinTypelineCapType(List<NSObject> partPt, double lineWidth, List<num> textureIndexs, bool isFoucs, bool keepScale, BMKLineJoinType lineJoinType, BMKLineCapType lineCapType, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderMultiTexturedPolyLineWithPartPoints([\'lineWidth\':$lineWidth, \'textureIndexs\':$textureIndexs, \'isFoucs\':$isFoucs, \'keepScale\':$keepScale])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderMultiTexturedPolyLineWithPartPointsLineWidthtextureIndexsisFoucskeepScalelineJoinTypelineCapType', {"partPt": partPt.map((it) => it.refId).toList(), "lineWidth": lineWidth, "textureIndexs": textureIndexs, "isFoucs": isFoucs, "keepScale": keepScale, "lineJoinType": lineJoinType.index, "lineCapType": lineCapType.index, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderMultiDashPolyLineWithPartPointsLineWidthtextureIndexslineDashType(List<NSObject> partPt, double lineWidth, List<num> textureIndexs, BMKLineDashType lineDashType, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderMultiDashPolyLineWithPartPoints([\'lineWidth\':$lineWidth, \'textureIndexs\':$textureIndexs])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderMultiDashPolyLineWithPartPointsLineWidthtextureIndexslineDashType', {"partPt": partPt.map((it) => it.refId).toList(), "lineWidth": lineWidth, "textureIndexs": textureIndexs, "lineDashType": lineDashType.index, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderRegionWithPointsPointCountfillColorusingTriangleFan(List<BMKMapPoint> points, int pointCount, UIColor fillColor, bool usingTriangleFan, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderRegionWithPoints([\'pointCount\':$pointCount, \'usingTriangleFan\':$usingTriangleFan])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderRegionWithPointsPointCountfillColorusingTriangleFan', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "fillColor": fillColor.refId, "usingTriangleFan": usingTriangleFan, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderATRegionWithPointPointCountfillColorusingTriangleFan(List<BMKMapPoint> points, int pointCount, UIColor fillColor, bool usingTriangleFan, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::renderATRegionWithPoint([\'pointCount\':$pointCount, \'usingTriangleFan\':$usingTriangleFan])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderATRegionWithPointPointCountfillColorusingTriangleFan', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "fillColor": fillColor.refId, "usingTriangleFan": usingTriangleFan, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> rendeCircleWithPointsPointCountlineWidthfillColorstrokeColor(List<BMKMapPoint> points, int pointCount, double lineWidth, UIColor fillColor, UIColor strokeColor, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::rendeCircleWithPoints([\'pointCount\':$pointCount, \'lineWidth\':$lineWidth])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::rendeCircleWithPointsPointCountlineWidthfillColorstrokeColor', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "lineWidth": lineWidth, "fillColor": fillColor.refId, "strokeColor": strokeColor.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> rendePolygonWithPointsPointCountlineWidthfillColorstrokeColor(List<BMKMapPoint> points, int pointCount, double lineWidth, UIColor fillColor, UIColor strokeColor, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::rendePolygonWithPoints([\'pointCount\':$pointCount, \'lineWidth\':$lineWidth])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::rendePolygonWithPointsPointCountlineWidthfillColorstrokeColor', {"points": points.map((it) => it.refId).toList(), "pointCount": pointCount, "lineWidth": lineWidth, "fillColor": fillColor.refId, "strokeColor": strokeColor.refId, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> glRender({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::glRender([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::glRender', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<bool> loadStrokeTextureImages(List<UIImage> textureImages, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: BMKOverlayView@$refId::loadStrokeTextureImages([])');
    }
  
    // invoke native method
    final result = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::loadStrokeTextureImages', {"textureImages": textureImages.map((it) => it.refId).toList(), "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  //endregion
}

extension BMKOverlayView_Batch on List<BMKOverlayView> {
  //region getters
  Future<List<BMKOverlay>> get_overlay_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKOverlayView::get_overlay_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => BMKGroundOverlay()..refId = result..tag = 'bmap_map_fluttify').toList();
    kNativeObjectPool.addAll(typedResult);
    return typedResult;
  }
  
  Future<List<List<UIColor>>> get_colors_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod("BMKOverlayView::get_colors_batch", [for (final item in this) {'refId': item.refId}]);
    final typedResult = (resultBatch as List).map((result) => (result as List).cast<int>().map((it) => UIColor()..refId = it..tag = 'bmap_map_fluttify').toList()).toList();
    kNativeObjectPool.addAll(typedResult.expand((e) => e));
    return typedResult;
  }
  
  //endregion

  //region methods
  Future<void> setOverlayGeometryDelegate_batch(List<NSObject> delegate, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::setOverlayGeometryDelegate_batch', [for (int i = 0; i < this.length; i++) {"delegate": delegate[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<NSObject>> initWithOverlay_batch(List<BMKOverlay> overlay, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::initWithOverlay_batch', [for (int i = 0; i < this.length; i++) {"overlay": overlay[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => NSObject()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGPoint>> pointForMapPoint_batch(List<BMKMapPoint> mapPoint, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::pointForMapPoint_batch', [for (int i = 0; i < this.length; i++) {"mapPoint": mapPoint[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<BMKMapPoint>> mapPointForPoint_batch(List<CGPoint> point, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::mapPointForPoint_batch', [for (int i = 0; i < this.length; i++) {"point": point[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapPoint()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<CGRect>> rectForMapRect_batch(List<BMKMapRect> mapRect, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::rectForMapRect_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => CGRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<BMKMapRect>> mapRectForRect_batch(List<CGRect> rect, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::mapRectForRect_batch', [for (int i = 0; i < this.length; i++) {"rect": rect[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => BMKMapRect()..refId = result..tag = 'bmap_map_fluttify').toList();
      kNativeObjectPool.addAll(typedResult);
      return typedResult;
    }
  }
  
  Future<List<bool>> canDrawMapRectZoomScale_batch(List<BMKMapRect> mapRect, List<double> zoomScale, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::canDrawMapRectZoomScale_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "zoomScale": zoomScale[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> setNeedsDisplayInMapRect_batch(List<BMKMapRect> mapRect, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::setNeedsDisplayInMapRect_batch', [for (int i = 0; i < this.length; i++) {"mapRect": mapRect[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderLinesWithPointsPointCountstrokeColorlineWidthlooped_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<UIColor> strokeColor, List<double> lineWidth, List<bool> looped, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderLinesWithPointsPointCountstrokeColorlineWidthlooped_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "strokeColor": strokeColor[i].refId, "lineWidth": lineWidth[i], "looped": looped[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDashType_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<UIColor> strokeColor, List<double> lineWidth, List<bool> looped, List<BMKLineDashType> lineDashType, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDashType_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "strokeColor": strokeColor[i].refId, "lineWidth": lineWidth[i], "looped": looped[i], "lineDashType": lineDashType[i].index, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDash_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<UIColor> strokeColor, List<double> lineWidth, List<bool> looped, List<bool> lineDash, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderLinesWithPointsPointCountstrokeColorlineWidthloopedlineDash_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "strokeColor": strokeColor[i].refId, "lineWidth": lineWidth[i], "looped": looped[i], "lineDash": lineDash[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocus_batch(List<List<NSObject>> partPt, List<double> lineWidth, List<List<NSObject>> textureIndexs, List<bool> isFoucs, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocus_batch', [for (int i = 0; i < this.length; i++) {"partPt": partPt[i].map((it) => it.refId).toList(), "lineWidth": lineWidth[i], "textureIndexs": textureIndexs[i].map((it) => it.refId).toList(), "isFoucs": isFoucs[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocustileTexturekeepScale_batch(List<List<NSObject>> partPt, List<double> lineWidth, List<List<NSObject>> textureIndexs, List<bool> isFoucs, List<bool> tileTexture, List<bool> keepscale, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderTexturedLinesWithPartPointsLineWidthtextureIndexsisFocustileTexturekeepScale_batch', [for (int i = 0; i < this.length; i++) {"partPt": partPt[i].map((it) => it.refId).toList(), "lineWidth": lineWidth[i], "textureIndexs": textureIndexs[i].map((it) => it.refId).toList(), "isFoucs": isFoucs[i], "tileTexture": tileTexture[i], "keepscale": keepscale[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderMultiTexturedPolyLineWithPartPointsLineWidthtextureIndexsisFoucskeepScalelineJoinTypelineCapType_batch(List<List<NSObject>> partPt, List<double> lineWidth, List<List<num>> textureIndexs, List<bool> isFoucs, List<bool> keepScale, List<BMKLineJoinType> lineJoinType, List<BMKLineCapType> lineCapType, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderMultiTexturedPolyLineWithPartPointsLineWidthtextureIndexsisFoucskeepScalelineJoinTypelineCapType_batch', [for (int i = 0; i < this.length; i++) {"partPt": partPt[i].map((it) => it.refId).toList(), "lineWidth": lineWidth[i], "textureIndexs": textureIndexs[i], "isFoucs": isFoucs[i], "keepScale": keepScale[i], "lineJoinType": lineJoinType[i].index, "lineCapType": lineCapType[i].index, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderMultiDashPolyLineWithPartPointsLineWidthtextureIndexslineDashType_batch(List<List<NSObject>> partPt, List<double> lineWidth, List<List<num>> textureIndexs, List<BMKLineDashType> lineDashType, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderMultiDashPolyLineWithPartPointsLineWidthtextureIndexslineDashType_batch', [for (int i = 0; i < this.length; i++) {"partPt": partPt[i].map((it) => it.refId).toList(), "lineWidth": lineWidth[i], "textureIndexs": textureIndexs[i], "lineDashType": lineDashType[i].index, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderRegionWithPointsPointCountfillColorusingTriangleFan_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<UIColor> fillColor, List<bool> usingTriangleFan, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderRegionWithPointsPointCountfillColorusingTriangleFan_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "fillColor": fillColor[i].refId, "usingTriangleFan": usingTriangleFan[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> renderATRegionWithPointPointCountfillColorusingTriangleFan_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<UIColor> fillColor, List<bool> usingTriangleFan, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::renderATRegionWithPointPointCountfillColorusingTriangleFan_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "fillColor": fillColor[i].refId, "usingTriangleFan": usingTriangleFan[i], "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> rendeCircleWithPointsPointCountlineWidthfillColorstrokeColor_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<double> lineWidth, List<UIColor> fillColor, List<UIColor> strokeColor, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::rendeCircleWithPointsPointCountlineWidthfillColorstrokeColor_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "lineWidth": lineWidth[i], "fillColor": fillColor[i].refId, "strokeColor": strokeColor[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> rendePolygonWithPointsPointCountlineWidthfillColorstrokeColor_batch(List<List<BMKMapPoint>> points, List<int> pointCount, List<double> lineWidth, List<UIColor> fillColor, List<UIColor> strokeColor, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::rendePolygonWithPointsPointCountlineWidthfillColorstrokeColor_batch', [for (int i = 0; i < this.length; i++) {"points": points[i].map((it) => it.refId).toList(), "pointCount": pointCount[i], "lineWidth": lineWidth[i], "fillColor": fillColor[i].refId, "strokeColor": strokeColor[i].refId, "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<void> glRender_batch({bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::glRender_batch', [for (int i = 0; i < this.length; i++) {"refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  Future<List<bool>> loadStrokeTextureImages_batch(List<List<UIImage>> textureImages, {bool viewChannel = true}) async {
    // print log
    // if (fluttifyLogEnabled) {
    //   #__log__#
    // }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'com.fluttify/bmap_map_fluttify/BMKOverlayView' : 'com.fluttify/bmap_map_fluttify').invokeMethod('BMKOverlayView::loadStrokeTextureImages_batch', [for (int i = 0; i < this.length; i++) {"textureImages": textureImages[i].map((it) => it.refId).toList(), "refId": this[i].refId}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).map((result) => result).toList();
    
      return typedResult;
    }
  }
  
  //endregion
}